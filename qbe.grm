structure T = QbeTypes

%%
%name Qbe
%term
    EOF
  | TYPE | ALIGN | EXPORT | SECTION | DATA | FUNCTION
  | ADD | SUB | DIV | MUL | NEG | UDIV | REM | UREM | OR | XOR | AND | SAR | SHR
  | SHL
  | STORED | STORES | STOREL | STOREW | STOREH | STOREB
  | LOADD | LOADS | LOADL | LOADW | LOADSW | LOADUW | LOADSH | LOADUH | LOADSB
  | LOADUB
  | ALLOC4 | ALLOC8 | ALLOC16
  | CEQD | CEQL | CEQS | CEQW | CGED | CGES | CGTD | CGTS | CLED | CLES | CLTD 
  | CLTS | CNED | CNEL | CNES | CNEW | COD  | COS  | CSGEL | CSGEW | CSGTL
  | CSGTW | CSLEL | CSLEW | CSLTL | CSLTW | CUGEL | CUGEW | CUGTL | CUGTW
  | CULEL | CULEW | CULTL | CULTW | CUOD | CUOS 
  | DTOSI | DTOUI | EXTS  | EXTSB | EXTSH | EXTSW | EXTUB | EXTUH | EXTUW
  | SLTOF | ULTOF | STOSI | STOUI | SWTOF | UWTOF | TRUNCD
  | CAST | COPY
  | CALL
  | VASTART | VAARG
  | PHI
  | JMP | JNZ | RET | RETW
  | NOP
  | W | L | S | D | B | H | Z
  | PLUS | EQ | COMMA | LPAREN | RPAREN | LBRACE | RBRACE | ENV | DOTS
  | TYP of Atom.atom
  | GLO of Atom.atom
  | TMP of Atom.atom
  | LBL of Atom.atom
  | INT of Int64.int
  | FLTS of Real64.real
  | FLTD of Real64.real
  | STR of string

%pos int
%pure
%eop EOF
%noshift EOF

%value TYP (Atom.atom ":bogus")
%value GLO (Atom.atom "$bogus")
%value TMP (Atom.atom "%bogus")
%value LBL (Atom.atom "@bogus")
%value INT (1)
%value FLTS (1.0)
%value FLTD (1.0)
%value STR ("")

%keyword TYPE ALIGN EXPORT SECTION DATA FUNCTION
%prefer LBL

%nonterm
    module of T.def list
  | defs of T.def list
  | def of  T.def
  | i32 of int
  | tylist of (T.ty * int) list
  | ty_num of T.ty * int
  | typ of T.ty
  | linkage of T.linkage
  | section of T.section
  | align_opt of int option
  | data_fields of T.datafield list
  | data_field of T.datafield
  | data_items of T.dataitem list
  | data_item of T.dataitem
  | const of T.const
  | typ_opt of T.ty option
  | env_params of {params: (T.ty * Atom.atom) list,
                   envp: Atom.atom option,
                   variadic: bool}
  | params of {params: (T.ty * Atom.atom) list, variadic: bool}
  | param of T.ty * Atom.atom
  | blocks of T.block list
  | block of T.block
  | phis_stmts of T.phi list * T.stmt list
  | phi of T.phi
  | phiargs of (Atom.atom * T.value) list
  | phiarg of Atom.atom * T.value
  | stmts of T.stmt list
  | stmt of T.stmt
  | jump of T.stmt option
  | value of T.value
  | ret of T.value option -> T.stmt
  | tmp_opt of (Atom.atom * T.ty) option
  | env_args of {envp: T.value option,
                 args: (T.ty * T.value) list,
                 vararg: int option}
  | args of {args: (T.ty * T.value) list, vararg: int option, i: int}
  | arg of (T.ty * T.value) option
  | ins1 of T.value -> T.instr
  | ins2 of T.value * T.value -> T.instr
  | store of T.value * T.value -> T.stmt

%%

module : defs                           (defs)

defs :                                  ([])
     | def defs                         (def::defs)

def : TYPE TYP EQ LBRACE tylist RBRACE          (T.Type{name=TYP,align=NONE,items=tylist})
    | TYPE TYP EQ ALIGN i32 LBRACE tylist RBRACE(T.Type{name=TYP,align=SOME i32,items=tylist})
    | TYPE TYP EQ ALIGN i32 LBRACE i32 RBRACE   (T.OpaqueType{name=TYP,align=i32,size=i32})
    | linkage DATA GLO EQ align_opt LBRACE data_fields RBRACE
        (T.Data {name = GLO,
                 linkage = linkage,
                 align = align_opt,
                 fields = data_fields})
    | linkage FUNCTION typ_opt GLO LPAREN env_params RPAREN LBRACE blocks RBRACE
        (T.Function {name = GLO,
                     linkage = linkage,
                     params = #params env_params,
                     envp = #envp env_params,
                     variadic = #variadic env_params,
                     result = typ_opt,
                     blocks = blocks})

tylist :                                  ([])
       | ty_num                           ([ty_num])
       | ty_num COMMA tylist              (ty_num::tylist)

ty_num : typ                              (typ, 1)
       | typ i32                          (typ, i32)

i32 : INT                                 (Int64.toInt INT)

typ : W                                   (T.W)
    | L                                   (T.L)
    | S                                   (T.S)
    | D                                   (T.D)
    | B                                   (T.B)
    | H                                   (T.H)
    | TYP                                 (T.Aggr TYP)

linkage :                                 ({exported=false, section=NONE})
        | EXPORT                          ({exported=true, section=NONE})
        | EXPORT section                  ({exported=true, section=SOME section})
        | section EXPORT                  ({exported=true, section=SOME section})

section : SECTION STR                     ({name=STR, flags=NONE})
        | SECTION STR STR                 ({name=STR1, flags=SOME STR2})

align_opt :                               (NONE)
          | ALIGN i32                     (SOME i32)

data_fields :                             ([])
            | data_field                  ([data_field])
            | data_field COMMA data_fields(data_field::data_fields)

data_field : typ data_items               (T.DataTy(typ, data_items))
           | Z i32                        (T.DataZ i32)

data_items : data_item                    ([data_item])
           | data_item data_items         (data_item::data_items)

data_item : GLO                           (T.DataSym(GLO, 0))
          | GLO PLUS i32                  (T.DataSym(GLO, i32))
          | STR                           (T.DataStr STR)
          | const                         (T.DataCon const)

const : INT                               (T.Int INT)
      | FLTS                              (T.Flts FLTS)
      | FLTD                              (T.Fltd FLTD)

typ_opt :                                 (NONE)
        | typ                             (SOME typ)

env_params : params                       ({params = #params params,
                                            envp = NONE,
                                            variadic = #variadic params})
           | ENV TMP                      ({params = [],
                                            envp = SOME TMP,
                                            variadic = false})
           | ENV TMP COMMA params         ({params = #params params,
                                            envp = SOME TMP,
                                            variadic = #variadic params})

params :                                  ({params=[], variadic=false})
       | DOTS                             ({params=[], variadic=true})
       | DOTS COMMA                       ({params=[], variadic=true})
       | param                            ({params=[param], variadic=false})
       | param COMMA params               ({params = param::(#params params),
                                            variadic = #variadic params})

param : typ TMP                           ((typ, TMP))

blocks : block                            ([block])
       | block blocks                     (block::blocks)

block : LBL phis_stmts jump               ({label=LBL, phis=(#1 phis_stmts),
                                            stmts=(#2 phis_stmts), jump=jump})

phis_stmts : phi phis_stmts               (phi::(#1 phis_stmts), #2 phis_stmts)
           | stmts                        ([], stmts)

phi : TMP EQ typ PHI phiargs              ({temp=(TMP, typ), args=phiargs})

phiargs : phiarg                          ([phiarg])
        | phiarg COMMA phiargs            (phiarg::phiargs)

phiarg : LBL value                        ((LBL, value))

stmts :                                   ([])
      | stmt stmts                        (stmt::stmts)

stmt : TMP EQ typ ins1 value              (T.Assign(TMP, typ, ins1 value))
     | TMP EQ typ ins2 value COMMA value  (T.Assign(TMP, typ, ins2(value1, value2)))
     | store value COMMA value            (store(value1, value2))
     | tmp_opt CALL GLO LPAREN env_args RPAREN
(
  T.Call {result = tmp_opt,
          name = GLO,
          envp = #envp env_args,
          args = #args env_args,
          vararg = #vararg env_args}
)
     | VASTART value                      (T.Vastart value)
     | NOP                                (T.Nop)

jump :                                    (NONE)
     | JMP LBL                            (SOME(T.Jmp LBL))
     | JNZ value COMMA LBL COMMA LBL      (SOME(T.Jnz(value, LBL1, LBL2)))
     | ret                                (SOME(ret NONE))
     | ret value                          (SOME(ret(SOME value)))

value : TMP                               (T.Tmp TMP)
      | GLO                               (T.Glo GLO)
      | const                             (T.Con const)

ret : RET                                 (T.Ret)
    | RETW                                (T.Retw)

tmp_opt :                                 (NONE)
        | TMP EQ typ                      (SOME(TMP, typ))

env_args : args
(
  {envp = NONE,
   args = #args args,
   vararg = Option.map (fn i => length(#args args) - i) (#vararg args)}
)
         | ENV value                  ({envp=SOME value, args=[], vararg=NONE})
         | ENV value COMMA args
(
  {envp = SOME value,
   args = #args args,
   vararg = Option.map (fn i => length(#args args) - i) (#vararg args)}
)

args :                                    ({args=[], vararg=NONE, i= ~1})
     | arg
(
   case arg
     of NONE => {args=[], vararg=SOME 0, i=0}
      | SOME a => {args=[a], vararg=NONE, i=0}
)
     | arg COMMA args
(
  let val {args, vararg, i} = args
      val i = i + 1
   in case arg
        of NONE => {args=args, vararg=SOME i, i=i}
         | SOME a => {args=a::args, vararg=vararg, i=i}
  end
)

arg : typ value                           (SOME(typ, value))
    | DOTS                                (NONE) (* variadic marker *)

ins1 : NEG                                (T.Neg)
     | LOADD                              (T.Loadd)
     | LOADS                              (T.Loads)
     | LOADL                              (T.Loadl)
     | LOADW                              (T.Loadw)
     | LOADSW                             (T.Loadsw)
     | LOADUW                             (T.Loaduw)
     | LOADSH                             (T.Loadsh)
     | LOADUH                             (T.Loaduh)
     | LOADSB                             (T.Loadsb)
     | LOADUB                             (T.Loadub)
     | ALLOC4                             (T.Alloc4)
     | ALLOC8                             (T.Alloc8)
     | ALLOC16                            (T.Alloc16)
     | DTOSI                              (T.Dtosi)
     | DTOUI                              (T.Dtoui)
     | EXTS                               (T.Exts)
     | EXTSB                              (T.Extsb)
     | EXTSH                              (T.Extsh)
     | EXTSW                              (T.Extsw)
     | EXTUB                              (T.Extub)
     | EXTUH                              (T.Extuh)
     | EXTUW                              (T.Extuw)
     | SLTOF                              (T.Sltof)
     | ULTOF                              (T.Ultof)
     | STOSI                              (T.Stosi)
     | STOUI                              (T.Stoui)
     | SWTOF                              (T.Swtof)
     | UWTOF                              (T.Uwtof)
     | TRUNCD                             (T.Truncd)
     | CAST                               (T.Cast)
     | COPY                               (T.Copy)
     | VAARG                              (T.Vaarg)

ins2 : ADD                                (T.Add)
     | SUB                                (T.Sub)
     | DIV                                (T.Div)
     | MUL                                (T.Mul)
     | UDIV                               (T.Udiv)
     | REM                                (T.Rem)
     | UREM                               (T.Urem)
     | OR                                 (T.Or)
     | XOR                                (T.Xor)
     | AND                                (T.And)
     | SAR                                (T.Sar)
     | SHR                                (T.Shr)
     | SHL                                (T.Shl)
     | CEQD                               (T.Ceqd)
     | CEQL                               (T.Ceql)
     | CEQS                               (T.Ceqs)
     | CEQW                               (T.Ceqw)
     | CGED                               (T.Cged)
     | CGES                               (T.Cges)
     | CGTD                               (T.Cgtd)
     | CGTS                               (T.Cgts)
     | CLED                               (T.Cled)
     | CLES                               (T.Cles)
     | CLTD                               (T.Cltd)
     | CLTS                               (T.Clts)
     | CNED                               (T.Cned)
     | CNEL                               (T.Cnel)
     | CNES                               (T.Cnes)
     | CNEW                               (T.Cnew)
     | COD                                (T.Cod)
     | COS                                (T.Cos)
     | CSGEL                              (T.Csgel)
     | CSGEW                              (T.Csgew)
     | CSGTL                              (T.Csgtl)
     | CSGTW                              (T.Csgtw)
     | CSLEL                              (T.Cslel)
     | CSLEW                              (T.Cslew)
     | CSLTL                              (T.Csltl)
     | CSLTW                              (T.Csltw)
     | CUGEL                              (T.Cugel)
     | CUGEW                              (T.Cugew)
     | CUGTL                              (T.Cugtl)
     | CUGTW                              (T.Cugtw)
     | CULEL                              (T.Culel)
     | CULEW                              (T.Culew)
     | CULTL                              (T.Cultl)
     | CULTW                              (T.Cultw)
     | CUOD                               (T.Cuod)
     | CUOS                               (T.Cuos)

store : STORED                            (T.Stored)
      | STORES                            (T.Stores)
      | STOREL                            (T.Storel)
      | STOREW                            (T.Storew)
      | STOREH                            (T.Storeh)
      | STOREB                            (T.Storeb)
